<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>윷판 - 말 이동</title>
<style>
  :root{
    --bg:#070a14;
    --panel: rgba(255,255,255,.06);
    --line: rgba(255,255,255,.12);
    --text: #eaf0ff;
    --muted:#9aa7c7;
  }
  *{ box-sizing:border-box; }
  body{
    margin:0; padding:16px;
    background: radial-gradient(1200px 800px at 20% 0%, #1b2a63 0%, var(--bg) 60%);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
  }
  .wrap{
    max-width: 1200px;
    margin: 0 auto;
    display:grid;
    grid-template-columns: 1fr 320px;
    gap: 12px;
  }
  @media (max-width: 980px){
    .wrap{ grid-template-columns: 1fr; }
  }

  .board{
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border: 1px solid rgba(255,255,255,.10);
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .boardStage{
    position: relative;
    width: 100%;
    aspect-ratio: 2048 / 1152; /* 제공 이미지 비율 */
    background: #000;
  }
  .boardStage img{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit: cover;
    user-select:none;
    -webkit-user-drag:none;
  }
  svg{
    position:absolute; inset:0;
    width:100%; height:100%;
  }

  .side{
    background: var(--panel);
    border: 1px solid rgba(255,255,255,.10);
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    padding: 12px;
  }
  h1{ margin:0 0 10px; font-size:16px; }
  .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .pill{
    padding:6px 10px;
    border-radius:999px;
    border: 1px solid rgba(255,255,255,.16);
    color: var(--muted);
    font-size: 12px;
  }
  button{
    background:#2a3cff;
    color:#fff;
    border:0;
    padding:10px 12px;
    border-radius:10px;
    cursor:pointer;
    font-weight:700;
  }
  button.ghost{
    background: transparent;
    border: 1px solid rgba(255,255,255,.18);
    color: var(--text);
  }

  .hint{
    margin-top:10px;
    color: var(--muted);
    font-size:12px;
    line-height:1.35;
  }

  /* SVG */
  .nodeHit{
    fill: rgba(255,255,255,0.001); /* 클릭 히트영역(투명) */
    cursor: pointer;
  }
  .nodeVis{
    fill: rgba(255,255,255,.06);
    stroke: rgba(255,255,255,.25);
    stroke-width: 2;
  }

  .piece circle{ stroke: rgba(255,255,255,.9); stroke-width:2; }
  .piece text{ fill:#fff; font-weight:900; font-size:16px; user-select:none; pointer-events:none; }
  .pRed circle{ fill:#ff4d6d; }
  .pBlue circle{ fill:#4dd4ff; }
  .selected circle{ stroke-width: 4; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="board">
      <div class="boardStage" id="stage">
        <img id="boardImg" alt="윷판" />
        <svg id="svg" viewBox="0 0 2048 1152" aria-label="말 이동 오버레이"></svg>
      </div>
    </div>

    <div class="side">
      <h1>말 이동 컨트롤</h1>

      <div class="row">
        <span class="pill" id="selPill">선택: 없음</span>
        <span class="pill" id="modePill">모드: 노드 클릭 이동</span>
      </div>

      <div style="height:10px"></div>

      <div class="row">
        <button class="ghost" id="toggleNodesBtn">노드 표시: ON</button>
        <button class="ghost" id="resetBtn">리셋</button>
      </div>

      <div class="hint">
        1) 말을 클릭해서 선택<br/>
        2) 보드의 원(노드)을 클릭하면 그 위치로 <b>부드럽게</b> 이동<br/><br/>
        ※ 윷 던지기는 오프라인으로 직접 하고, 여기서는 결과만 반영해서 이동시키면 됨.
      </div>
    </div>
  </div>

<script>
/**
 * ✅ 이미지 경로만 바꾸면 됨
 * - 같은 폴더에 board.jpg로 두면 그대로 동작
 */
const BOARD_SRC = "board.jpg";

/**
 * ✅ 업로드해준 보드 이미지에서 자동 검출한 "원(노드) 중심 좌표" 29개 (정규화)
 * - 반응형을 위해 0~1 비율로 저장해두고 viewBox(2048x1152)로 환산
 * - 노드는 '클릭 히트영역' 용도라 번호/이름이 필요 없음
 */
const NODES_NORM = [
  [0.27832, 0.087674],[0.562988, 0.08941],[0.710449, 0.08941],[0.13623, 0.092014],[0.424316, 0.092014],
  [0.852539, 0.092014],[0.971191, 0.100694],[0.210938, 0.188368],[0.852539, 0.216146],[0.063477, 0.251736],
  [0.535645, 0.264757],[0.789551, 0.317708],[0.063477, 0.368056],[0.789551, 0.393229],[0.063477, 0.485243],
  [0.13623, 0.544271],[0.789551, 0.576389],[0.210938, 0.642361],[0.535645, 0.645833],[0.063477, 0.66059],
  [0.854004, 0.592014],[0.709961, 0.672743],[0.535645, 0.728299],[0.354004, 0.761285],[0.789551, 0.761285],
  [0.209961, 0.784722],[0.063477, 0.784722],[0.535645, 0.822917],[0.852051, 0.722222]
];

const VIEW_W = 2048, VIEW_H = 1152;
const toView = ([nx, ny]) => ({ x: nx * VIEW_W, y: ny * VIEW_H });

const svg = document.getElementById("svg");
const imgEl = document.getElementById("boardImg");
imgEl.src = BOARD_SRC;

let showNodes = true;

// 말(팀당 3개: 이미지 분위기와 동일)
const pieces = [
  { team:"red", label:"R1", node: 28 }, // 우하 START 근처(이미지의 START 원)
  { team:"red", label:"R2", node: 28 },
  { team:"red", label:"R3", node: 28 },

  { team:"blue", label:"B1", node: 28 },
  { team:"blue", label:"B2", node: 28 },
  { team:"blue", label:"B3", node: 28 }
];

let selectedPieceIndex = null;
let animating = false;

const selPill = document.getElementById("selPill");
const toggleNodesBtn = document.getElementById("toggleNodesBtn");
const resetBtn = document.getElementById("resetBtn");

function easeInOutCubic(t){
  return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
}

function setSelected(i){
  selectedPieceIndex = i;
  if(i === null){
    selPill.textContent = "선택: 없음";
  }else{
    selPill.textContent = `선택: ${pieces[i].label}`;
  }
  render();
}

function reset(){
  // 전부 START(28)로 복귀
  for(const p of pieces) p.node = 28;
  setSelected(null);
}

function draw(){
  svg.innerHTML = "";

  // 1) 노드(표시 ON일 때만 시각화)
  NODES_NORM.forEach((n, idx) => {
    const {x,y} = toView(n);

    if(showNodes){
      const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      c.setAttribute("cx", x);
      c.setAttribute("cy", y);
      c.setAttribute("r", 28);
      c.setAttribute("class", "nodeVis");
      svg.appendChild(c);
    }

    // 클릭 히트영역(항상)
    const hit = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    hit.setAttribute("cx", x);
    hit.setAttribute("cy", y);
    hit.setAttribute("r", 38);
    hit.setAttribute("class", "nodeHit");
    hit.addEventListener("click", () => onNodeClick(idx));
    svg.appendChild(hit);
  });

  // 2) 말 렌더
  // 같은 노드에 여러 말이 있을 때 살짝 퍼지게(겹침 방지)
  const groups = new Map(); // node -> piece indices
  pieces.forEach((p, i) => {
    const arr = groups.get(p.node) ?? [];
    arr.push(i);
    groups.set(p.node, arr);
  });

  pieces.forEach((p, i) => {
    const base = toView(NODES_NORM[p.node]);
    const same = groups.get(p.node);
    const k = same.indexOf(i);
    const m = same.length;

    const angle = (m === 1) ? 0 : (k / m) * Math.PI * 2;
    const rr = (m === 1) ? 0 : 22;
    const px = base.x + Math.cos(angle) * rr;
    const py = base.y + Math.sin(angle) * rr;

    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const cls = [
      "piece",
      p.team === "red" ? "pRed" : "pBlue",
      (selectedPieceIndex === i) ? "selected" : ""
    ].join(" ");
    g.setAttribute("class", cls);
    g.style.cursor = animating ? "not-allowed" : "pointer";
    g.addEventListener("click", () => {
      if(animating) return;
      setSelected(i);
    });

    const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    c.setAttribute("cx", px);
    c.setAttribute("cy", py);
    c.setAttribute("r", 20);

    const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
    t.setAttribute("x", px);
    t.setAttribute("y", py + 6);
    t.setAttribute("text-anchor", "middle");
    t.textContent = p.label;

    g.appendChild(c);
    g.appendChild(t);
    svg.appendChild(g);
  });
}

function render(){ draw(); }

function onNodeClick(targetNode){
  if(animating) return;
  if(selectedPieceIndex === null) return;

  const p = pieces[selectedPieceIndex];
  if(p.node === targetNode) return;

  animateMove(selectedPieceIndex, targetNode, 520);
}

function animateMove(pieceIndex, targetNode, durationMs){
  animating = true;

  const p = pieces[pieceIndex];
  const from = toView(NODES_NORM[p.node]);
  const to = toView(NODES_NORM[targetNode]);

  const start = performance.now();
  const temp = { x: from.x, y: from.y };

  function frame(now){
    const t = Math.min(1, (now - start) / durationMs);
    const e = easeInOutCubic(t);

    temp.x = from.x + (to.x - from.x) * e;
    temp.y = from.y + (to.y - from.y) * e;

    // 임시 렌더: 말 위치만 임시로 그리기 위해 node를 바꾸지 않고 직접 그리는 방식
    // -> 간단하게: 현재 SVG를 재구성하되 해당 말만 임시 좌표로 덮어쓰기
    svg.innerHTML = "";

    // 노드
    NODES_NORM.forEach((n, idx) => {
      const {x,y} = toView(n);
      if(showNodes){
        const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        c.setAttribute("cx", x);
        c.setAttribute("cy", y);
        c.setAttribute("r", 28);
        c.setAttribute("class", "nodeVis");
        svg.appendChild(c);
      }
      const hit = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      hit.setAttribute("cx", x);
      hit.setAttribute("cy", y);
      hit.setAttribute("r", 38);
      hit.setAttribute("class", "nodeHit");
      hit.addEventListener("click", () => onNodeClick(idx));
      svg.appendChild(hit);
    });

    // 겹침 방지용 그룹 계산(임시 이동 중인 말은 "가상 노드"로 취급)
    const groups = new Map();
    pieces.forEach((pp, ii) => {
      const key = (ii === pieceIndex) ? "__moving__" : pp.node;
      const arr = groups.get(key) ?? [];
      arr.push(ii);
      groups.set(key, arr);
    });

    pieces.forEach((pp, ii) => {
      let px, py;

      if(ii === pieceIndex){
        const same = groups.get("__moving__");
        const k = same.indexOf(ii);
        const m = same.length;
        const angle = (m === 1) ? 0 : (k / m) * Math.PI * 2;
        const rr = (m === 1) ? 0 : 22;
        px = temp.x + Math.cos(angle) * rr;
        py = temp.y + Math.sin(angle) * rr;
      }else{
        const base = toView(NODES_NORM[pp.node]);
        const same = groups.get(pp.node);
        const k = same.indexOf(ii);
        const m = same.length;
        const angle = (m === 1) ? 0 : (k / m) * Math.PI * 2;
        const rr = (m === 1) ? 0 : 22;
        px = base.x + Math.cos(angle) * rr;
        py = base.y + Math.sin(angle) * rr;
      }

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const cls = [
        "piece",
        pp.team === "red" ? "pRed" : "pBlue",
        (selectedPieceIndex === ii) ? "selected" : ""
      ].join(" ");
      g.setAttribute("class", cls);
      g.style.cursor = "not-allowed";

      const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      c.setAttribute("cx", px);
      c.setAttribute("cy", py);
      c.setAttribute("r", 20);

      const tt = document.createElementNS("http://www.w3.org/2000/svg", "text");
      tt.setAttribute("x", px);
      tt.setAttribute("y", py + 6);
      tt.setAttribute("text-anchor", "middle");
      tt.textContent = pp.label;

      g.appendChild(c);
      g.appendChild(tt);
      svg.appendChild(g);
    });

    if(t < 1){
      requestAnimationFrame(frame);
    }else{
      // 종료: 실제 위치 반영
      p.node = targetNode;
      animating = false;
      render();
    }
  }

  requestAnimationFrame(frame);
}

toggleNodesBtn.addEventListener("click", () => {
  showNodes = !showNodes;
  toggleNodesBtn.textContent = `노드 표시: ${showNodes ? "ON" : "OFF"}`;
  render();
});

resetBtn.addEventListener("click", reset);

render();
</script>
</body>
</html>
