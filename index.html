<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>윷판 5x5 - 말 이동</title>
<style>
  :root{
    --bg:#070a14;
    --panel: rgba(255,255,255,.06);
    --text:#eaf0ff;
    --muted:#9aa7c7;
  }
  *{ box-sizing:border-box; }
  body{
    margin:0; padding:16px;
    background: radial-gradient(1200px 800px at 20% 0%, #1b2a63 0%, var(--bg) 60%);
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
  }
  .wrap{
    max-width: 1100px; margin: 0 auto;
    display:grid; gap:12px;
    grid-template-columns: 1fr 320px;
  }
  @media (max-width: 980px){ .wrap{ grid-template-columns:1fr; } }

  .board{
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border: 1px solid rgba(255,255,255,.10);
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    overflow:hidden;
    padding: 10px;
  }
  svg{ width:100%; height:auto; display:block; }

  .side{
    background: var(--panel);
    border: 1px solid rgba(255,255,255,.10);
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    padding: 12px;
  }
  h1{ margin:0 0 10px; font-size:16px; }
  .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .pill{
    padding:6px 10px;
    border-radius:999px;
    border: 1px solid rgba(255,255,255,.16);
    color: var(--muted);
    font-size: 12px;
  }
  button{
    background:#2a3cff; color:#fff; border:0;
    padding:10px 12px; border-radius:10px;
    cursor:pointer; font-weight:800;
  }
  button.ghost{
    background: transparent;
    border: 1px solid rgba(255,255,255,.18);
    color: var(--text);
  }
  .hint{ margin-top:10px; color:var(--muted); font-size:12px; line-height:1.35; }

  /* SVG 스타일 */
  .edge{ stroke: rgba(255,255,255,.18); stroke-width:6; stroke-linecap:round; }
  .edge.diag{ stroke: rgba(255,255,255,.22); stroke-dasharray: 10 12; }
  .nodeVis{ fill: rgba(255,255,255,.06); stroke: rgba(255,255,255,.30); stroke-width:2; }
  .nodeHit{ fill: rgba(255,255,255,0.001); cursor:pointer; }

  .piece circle{ stroke: rgba(255,255,255,.9); stroke-width:2; }
  .piece text{ fill:#fff; font-weight:900; font-size:16px; user-select:none; pointer-events:none; }
  .pRed circle{ fill:#ff4d6d; }
  .pBlue circle{ fill:#4dd4ff; }
  .selected circle{ stroke-width:4; }
</style>
</head>
<body>
<div class="wrap">
  <div class="board">
    <svg id="svg" viewBox="0 0 1000 1000" aria-label="5x5 윷판"></svg>
  </div>

  <div class="side">
    <h1>5×5 윷판 (말 이동만)</h1>
    <div class="row">
      <span class="pill" id="selPill">선택: 없음</span>
      <span class="pill" id="infoPill">이동: 노드 클릭</span>
    </div>
    <div style="height:10px"></div>
    <div class="row">
      <button class="ghost" id="toggleIdxBtn">노드 번호: ON</button>
      <button class="ghost" id="toggleNodesBtn">노드 표시: ON</button>
      <button class="ghost" id="resetBtn">리셋</button>
    </div>
    <div class="hint">
      1) 말을 클릭해 선택<br/>
      2) 목표 노드 클릭 → 최단경로로 흘러가듯 이동<br/><br/>
      윷 결과(도/개/걸/윷/모)는 직접 던진 뒤, 목표 지점만 클릭해 이동시키면 됨.
    </div>
  </div>
</div>

<script>
/** ----------------------------
 *  보드 정의: 5×5 격자 + 2개 대각선
 *  - 노드: 25개 (r=0..4, c=0..4)
 *  - 간선: 가로/세로 전체 + (0,0)-(4,4), (0,4)-(4,0) 대각선 라인(각 5노드)
 *  ---------------------------- */

const svg = document.getElementById("svg");
const selPill = document.getElementById("selPill");

let showNodes = true;
let showIdx = true;
let animating = false;

const VIEW = 1000;
const M = 140;              // margin
const STEP = (VIEW - 2*M) / 4; // 5점 -> 4간격
const R_NODE = 26;
const R_HIT = 42;

const idx = (r,c)=> r*5 + c;
const rc = (i)=> ({ r: Math.floor(i/5), c: i%5 });

function posOf(i){
  const {r,c} = rc(i);
  return { x: M + c*STEP, y: M + r*STEP };
}
const REMOVED = new Set([7, 11, 13, 17]);

// 인접 리스트
const adj = Array.from({length:25}, ()=>[]);

// 가로/세로 연결(전체 격자)
for(let r=0;r<5;r++){
  for(let c=0;c<5;c++){
    const a = idx(r,c);
    if(c<4){ const b = idx(r,c+1); adj[a].push(b); adj[b].push(a); }
    if(r<4){ const b = idx(r+1,c); adj[a].push(b); adj[b].push(a); }
  }
}

// 대각선(각 5노드 라인)
for(let k=0;k<4;k++){
  // TL -> BR
  const a1 = idx(k,k), b1 = idx(k+1,k+1);
  adj[a1].push(b1); adj[b1].push(a1);

  // TR -> BL
  const a2 = idx(k,4-k), b2 = idx(k+1,3-k);
  adj[a2].push(b2); adj[b2].push(a2);
}

// 중복 제거
for(let i=0;i<25;i++){
  adj[i] = [...new Set(adj[i])];
}

  // ✅ 제거 노드: 인접 간선 완전 제거(들어가는/나가는 간선 모두)
for (const r of REMOVED) {
  // 다른 노드들이 r로 향하는 간선 제거
  for (let i=0;i<25;i++){
    adj[i] = adj[i].filter(v => v !== r);
  }
  // r 자체의 간선도 제거
  adj[r] = [];
}

// 말(원하는 만큼 조절 가능)
const pieces = [
  { team:"red",  label:"R1", node: idx(4,4) },
  { team:"red",  label:"R2", node: idx(4,4) },
  { team:"red",  label:"R3", node: idx(4,4) },
  { team:"red",  label:"R4", node: idx(4,4) },
  { team:"blue", label:"B1", node: idx(4,4) },
  { team:"blue", label:"B2", node: idx(4,4) },
  { team:"blue", label:"B3", node: idx(4,4) },
  { team:"blue", label:"B4", node: idx(4,4) },

];

let selectedPieceIndex = null;

function easeInOutCubic(t){
  return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2;
}

// BFS 최단경로
function shortestPath(start, goal){
  if(start===goal) return [start];
  const prev = Array(25).fill(-1);
  const q = [start];
  prev[start] = start;

  for(let qi=0; qi<q.length; qi++){
    const cur = q[qi];
    for(const nx of adj[cur]){
      if(prev[nx] !== -1) continue;
      prev[nx] = cur;
      if(nx === goal){
        // reconstruct
        const path = [goal];
        let p = cur;
        while(p !== start){
          path.push(p);
          p = prev[p];
        }
        path.push(start);
        path.reverse();
        return path;
      }
      q.push(nx);
    }
  }
  return [start]; // 연결 안되면(사실상 없음)
}

  const REMOVE_EDGES = new Set([
  "1-6",
  "5-6",
  "3-8",
  "8-9",
  "15-16",
  "16-21",
  "18-19",
  "18-23"
]);

// 렌더
function render(tempPiece=null){
  svg.innerHTML = "";

 // 간선 그리기 (중복 방지: i<j만)
for(let a=0;a<25;a++){
  const pa = posOf(a);

  for(const b of adj[a]){
    if(a >= b) continue;

    // ✅ 특정 간선 제거 (a<b 형태로만 검사하면 됨)
    if (REMOVE_EDGES.has(`${a}-${b}`)) continue;

    const pb = posOf(b);
    const isDiag = isDiagonalEdge(a,b);

    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1", pa.x); line.setAttribute("y1", pa.y);
    line.setAttribute("x2", pb.x); line.setAttribute("y2", pb.y);
    line.setAttribute("class", `edge ${isDiag ? "diag" : ""}`);
    svg.appendChild(line);
  }
}


// 노드
for(let i=0;i<25;i++){
  if (REMOVED.has(i)) continue;      // ✅ 제거 노드는 아예 그림/클릭 없음

  const p = posOf(i);

  if(showNodes){
    const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx", p.x); c.setAttribute("cy", p.y);
    c.setAttribute("r", R_NODE);
    c.setAttribute("class", "nodeVis");
    svg.appendChild(c);

    if(showIdx){
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", p.x);
      t.setAttribute("y", p.y + 6);
      t.setAttribute("text-anchor","middle");
      t.setAttribute("fill","rgba(255,255,255,.75)");
      t.setAttribute("font-size","14");
      t.setAttribute("font-weight","800");
      t.textContent = String(i);
      svg.appendChild(t);
    }
  }

  const hit = document.createElementNS("http://www.w3.org/2000/svg","circle");
  hit.setAttribute("cx", p.x); hit.setAttribute("cy", p.y);
  hit.setAttribute("r", R_HIT);
  hit.setAttribute("class","nodeHit");
  hit.addEventListener("click", ()=>onNodeClick(i));
  svg.appendChild(hit);
}


  // 말 겹침 오프셋
  const groups = new Map();
  pieces.forEach((pc, pi)=>{
    const key = (tempPiece && tempPiece.pi===pi) ? "__moving__" : pc.node;
    const arr = groups.get(key) ?? [];
    arr.push(pi);
    groups.set(key, arr);
  });

  pieces.forEach((pc, pi)=>{
    let base;
    if(tempPiece && tempPiece.pi===pi){
      base = {x: tempPiece.x, y: tempPiece.y};
    }else{
      base = posOf(pc.node);
    }

    const key = (tempPiece && tempPiece.pi===pi) ? "__moving__" : pc.node;
    const same = groups.get(key);
    const k = same.indexOf(pi);
    const m = same.length;

    const angle = (m===1)?0:(k/m)*Math.PI*2;
    const rr = (m===1)?0:22;
    const x = base.x + Math.cos(angle)*rr;
    const y = base.y + Math.sin(angle)*rr;

    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    const cls = [
      "piece",
      pc.team==="red" ? "pRed" : "pBlue",
      selectedPieceIndex===pi ? "selected" : ""
    ].join(" ");
    g.setAttribute("class", cls);
    g.style.cursor = animating ? "not-allowed" : "pointer";
    g.addEventListener("click", ()=>{
      if(animating) return;
      setSelected(pi);
    });

    const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx", x); c.setAttribute("cy", y);
    c.setAttribute("r", 20);

    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.setAttribute("x", x);
    t.setAttribute("y", y+6);
    t.setAttribute("text-anchor","middle");
    t.textContent = pc.label;

    g.appendChild(c); g.appendChild(t);
    svg.appendChild(g);
  });
}

function isDiagonalEdge(a,b){
  const A = rc(a), B = rc(b);
  const dr = Math.abs(A.r - B.r);
  const dc = Math.abs(A.c - B.c);
  return (dr===1 && dc===1); // 대각 인접
}

function setSelected(pi){
  selectedPieceIndex = pi;
  selPill.textContent = pi===null ? "선택: 없음" : `선택: ${pieces[pi].label}`;
  render();
}

function onNodeClick(target){
  if(animating) return;
  if(selectedPieceIndex===null) return;

  const pc = pieces[selectedPieceIndex];
  const path = shortestPath(pc.node, target);
  if(path.length<=1) return;

  animateAlongPath(selectedPieceIndex, path, 140); // segment duration(ms)
}

async function animateAlongPath(pi, path, segMs){
  animating = true;
  const pc = pieces[pi];

  for(let i=0;i<path.length-1;i++){
    const a = posOf(path[i]);
    const b = posOf(path[i+1]);
    await animateSegment(pi, a, b, segMs);
    pc.node = path[i+1];
  }

  animating = false;
  render();
}

function animateSegment(pi, from, to, durationMs){
  return new Promise((resolve)=>{
    const start = performance.now();

    function frame(now){
      const t = Math.min(1, (now-start)/durationMs);
      const e = easeInOutCubic(t);
      const x = from.x + (to.x - from.x) * e;
      const y = from.y + (to.y - from.y) * e;

      render({pi, x, y});

      if(t<1) requestAnimationFrame(frame);
      else resolve();
    }
    requestAnimationFrame(frame);
  });
}

document.getElementById("toggleNodesBtn").addEventListener("click", ()=>{
  showNodes = !showNodes;
  document.getElementById("toggleNodesBtn").textContent = `노드 표시: ${showNodes ? "ON":"OFF"}`;
  render();
});
document.getElementById("toggleIdxBtn").addEventListener("click", ()=>{
  showIdx = !showIdx;
  document.getElementById("toggleIdxBtn").textContent = `노드 번호: ${showIdx ? "ON":"OFF"}`;
  render();
});
document.getElementById("resetBtn").addEventListener("click", ()=>{
  for(const p of pieces) p.node = idx(4,4); // 기본 시작 위치(우하)
  setSelected(null);
});

render();
</script>
</body>
</html>
